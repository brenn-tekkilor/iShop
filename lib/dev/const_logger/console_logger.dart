import 'dart:convert';

import 'package:ishop/dev/const_logger/const_log_printer.dart';
import 'package:ishop/dev/const_logger/const_logger.dart';
import 'package:logger/logger.dart';

/// Default implementation of [LogPrinter].
///
/// Output looks like this:
/// ```
/// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// â”‚ Error info
/// â”œâ”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„
/// â”‚ Method stack history
/// â”œâ”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„
/// â”‚ Log message
/// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// ```
class ConsoleLogger extends ConstLogPrinter {
  const ConsoleLogger({String name = _defaultName})
      : className = name,
        methodCount = 0,
        errorMethodCount = 5,
        lineLength = 60,
        colors = true,
        printEmojis = true,
        printTime = false;

  static final DateTime _startTime = DateTime.now();
  static const topLeftCorner = 'â”Œ';
  static const bottomLeftCorner = 'â””';
  static const middleCorner = 'â”œ';
  static const verticalLine = 'â”‚';
  static const doubleDivider =
      'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
  static const singleDivider =
      'â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„';
  static final levelColors = {
    Level.verbose: AnsiColor.fg(AnsiColor.grey(0.5)),
    Level.debug: AnsiColor.none(),
    Level.info: AnsiColor.fg(12),
    Level.warning: AnsiColor.fg(208),
    Level.error: AnsiColor.fg(196),
    Level.wtf: AnsiColor.fg(199),
  };
  static final levelEmojis = {
    Level.verbose: '',
    Level.debug: 'ðŸ› ',
    Level.info: 'ðŸ’¡ ',
    Level.warning: 'âš ï¸ ',
    Level.error: 'â›” ',
    Level.wtf: 'ðŸ‘¾ ',
  };
  static const _defaultName = 'app';

  /// Matches a stacktrace line as generated on Android/iOS devices.
  /// For example:
  /// #1      Logger.log (package:logger/src/logger.dart:115:29)
  static final _deviceStackTraceRegex =
      RegExp(r'#[0-9]+[\s]+(.+) \(([^\s]+)\)');

  /// Matches a stacktrace line as generated by Flutter web.
  /// For example:
  /// packages/logger/src/printers/pretty_printer.dart 91:37
  static final _webStackTraceRegex =
      RegExp(r'^((packages|dart-sdk)\/[^\s]+\/)');

  /// Matches a stacktrace line as generated by browser Dart.
  /// For example:
  /// dart:sdk_internal
  /// package:logger/src/logger.dart
  static final _browserStackTraceRegex =
      RegExp(r'^(?:package:)?(dart:[^\s]+|[^\s]+)');

  //#region properties
  final int methodCount;
  final int errorMethodCount;
  final int lineLength;
  final bool colors;
  final bool printEmojis;
  final bool printTime;
  final String className;

  String get _topBorder => '$topLeftCorner$doubleDivider';
  String get _middleBorder => '$middleCorner$singleDivider';
  String get _bottomBorder => '$bottomLeftCorner$doubleDivider';
  //#endregion

  static ConstLogger getLogger({String name = 'app'}) =>
      ConstLogger(printer: ConsoleLogger(name: name));

  @override
  List<String> log(LogEvent event) {
    var messageStr = stringifyMessage(event.message);
    var stackTraceStr = '';
    if (event.stackTrace == null) {
      if (methodCount > 0) {
        stackTraceStr = formatStackTrace(StackTrace.current, methodCount);
      }
    } else if (errorMethodCount > 0) {
      stackTraceStr = formatStackTrace(event.stackTrace, errorMethodCount);
    }
    var errorStr = event.error?.toString() ?? '';
    var timeStr = '';
    if (printTime) {
      timeStr = getTime();
    }
    return _formatAndPrint(
      event.level,
      className,
      messageStr,
      timeStr,
      errorStr,
      stackTraceStr,
    );
  }

  String formatStackTrace(StackTrace stackTrace, int methodCount) {
    var lines = stackTrace.toString().split('\n');
    var formatted = <String>[];
    var count = 0;
    for (var line in lines) {
      if (_discardDeviceStacktraceLine(line) ||
          _discardWebStacktraceLine(line) ||
          _discardBrowserStacktraceLine(line)) {
        continue;
      }
      formatted.add('#$count   ${line.replaceFirst(RegExp(r'#\d+\s+'), '')}');
      if (++count == methodCount) {
        break;
      }
    }

    if (formatted.isEmpty) {
      return '';
    } else {
      return formatted.join('\n');
    }
  }

  bool _discardDeviceStacktraceLine(String line) {
    var match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match != null) {
      final g = match.group(2);
      if (g != null) {
        return g.startsWith('package:logger');
      }
    }
    return false;
  }

  bool _discardWebStacktraceLine(String line) {
    var match = _webStackTraceRegex.matchAsPrefix(line);
    if (match != null) {
      final g = match.group(1);
      if (g != null) {
        return (g.startsWith('packages/logger') ||
            g.startsWith('dart-sdk/lib'));
      }
    }
    return false;
  }

  bool _discardBrowserStacktraceLine(String line) {
    var match = _browserStackTraceRegex.matchAsPrefix(line);
    if (match != null) {
      final g = match.group(1);
      if (g != null) {
        return (g.startsWith('package:logger') || g.startsWith('dart:'));
      }
    }
    return false;
  }

  String getTime() {
    String _threeDigits(int n) {
      if (n >= 100) return '$n';
      if (n >= 10) return '0$n';
      return '00$n';
    }

    String _twoDigits(int n) {
      if (n >= 10) return '$n';
      return '0$n';
    }

    var now = DateTime.now();
    var h = _twoDigits(now.hour);
    var min = _twoDigits(now.minute);
    var sec = _twoDigits(now.second);
    var ms = _threeDigits(now.millisecond);
    var timeSinceStart = now.difference(_startTime).toString();
    return '$h:$min:$sec.$ms (+$timeSinceStart)';
  }

  String stringifyMessage(dynamic message) {
    if (message is Map || message is Iterable) {
      var encoder = JsonEncoder.withIndent('  ');
      return encoder.convert(message);
    } else {
      return message.toString();
    }
  }

  AnsiColor? _getLevelColor(Level level) {
    if (colors) {
      return levelColors[level];
    } else {
      return AnsiColor.none();
    }
  }

  AnsiColor _getErrorColor(Level level) {
    if (colors) {
      if (level == Level.wtf) {
        final w = levelColors[Level.wtf];
        if (w != null) {
          return w.toBg();
        }
      } else {
        final e = levelColors[Level.error];
        if (e != null) {
          return e.toBg();
        }
      }
    }
    return AnsiColor.none();
  }

  String _getEmoji(Level level) {
    if (printEmojis) {
      return levelEmojis[level] ?? '';
    } else {
      return '';
    }
  }

  List<String> _formatAndPrint(
    Level level,
    String className,
    String message,
    String time,
    String error,
    String stacktrace,
  ) {
    // This code is non trivial and a type annotation here helps understanding.
    // ignore: omit_local_variable_types
    List<String> buffer = [];
    var color = _getLevelColor(level);
    if (color != null) {
      buffer.add(color(_topBorder));

      var errorColor = _getErrorColor(level);
      for (var line in error.split('\n')) {
        buffer.add(
          color('$verticalLine ') +
              errorColor.resetForeground +
              errorColor(line) +
              errorColor.resetBackground,
        );
      }
      buffer.add(color(_middleBorder));
    }

    for (var line in stacktrace.split('\n')) {
      buffer.add('$color$verticalLine $line');
    }
    if (color != null) {
      buffer.add(color(_middleBorder));
      buffer..add(color('$verticalLine $time'))..add(color(_middleBorder));
      var emoji = _getEmoji(level);
      for (var line in message.split('\n')) {
        buffer.add(color('$verticalLine $emoji $className - $line'));
      }
      buffer.add(color(_bottomBorder));
    }
    return buffer;
  }
}
